# 개념
- 사용자의 가능 요일과 시간대를 관리하는 테이블.
- user의 타입별로 의미하는 바가 다름.
- member의 경우는 운동을 할 수 있는 요일과 시간대를 의미함.
- trainer의 경우는 자신의 근무하는 요일과 시간대를 의미함.

# 컬럼 명세
- `id`: 타임 슬롯 고유 ID (Primary Key)
- `user_id`: 사용자 ID (`users.id` 참조)
- `available_day`: 활동 가능한 요일 (ENUM 타입)
- `time_block`: 30분 단위의 시간 블록 인덱스 (0 = 00:00~00:30, ..., 47 = 23:30~24:00)

# 쿼리문
```sql
-- 요일을 나타내는 ENUM 타입을 먼저 정의합니다.
DROP TYPE IF EXISTS day_of_week CASCADE;
CREATE TYPE day_of_week AS ENUM ('MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY');

-- 기존 테이블이 있다면 삭제
DROP TABLE IF EXISTS user_time_slots CASCADE;

-- 각 사용자의 활동 가능 "시간 블록"을 저장하는 테이블
-- 테이블 이름 변경: user_availabilities -> user_time_slots
CREATE TABLE user_time_slots (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,

  -- 어떤 요일, 어떤 시간 블록이 가능한지를 저장합니다.
  available_day day_of_week NOT NULL,
  time_block SMALLINT NOT NULL, -- 0~47 사이의 숫자 (하루를 30분 단위로 쪼갠 48개 블록)

  -- 한 사용자가 동일한 요일, 동일한 시간 블록을 중복으로 저장할 수 없도록 UNIQUE 제약 조건 설정
  UNIQUE(user_id, available_day, time_block),

  -- users 테이블 외래 키 설정
  CONSTRAINT fk_user_time_slot FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 인덱스 이름도 테이블 이름에 맞춰 수정
CREATE INDEX idx_user_time_slots_user_id ON user_time_slots(user_id);
CREATE INDEX idx_user_time_slots_day_block ON user_time_slots(available_day, time_block);

-- 주석 추가
COMMENT ON TABLE user_time_slots IS '사용자의 활동 가능 시간을 30분 단위의 블록(슬롯)으로 저장하는 테이블';
COMMENT ON COLUMN user_time_slots.time_block IS '시간 블록 인덱스 (0 = 00:00~00:30, 1 = 00:30~01:00, ..., 47 = 23:30~24:00)';
```